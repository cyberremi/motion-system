<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Camera Sender — Optimized</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{--bg:#071026;--card:#0f1724;--text:#e8eefc;--accent:#4da3ff}
    body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);padding:14px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px;max-width:720px;margin:0 auto}
    h2{margin:0 0 10px 0;color:var(--accent)}
    video, canvas{width:100%;border-radius:8px;background:#000;display:block}
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
    input[type=number], input[type=range] {padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#07102a;cursor:pointer;font-weight:700}
    #log{margin-top:8px;background:#07182a;padding:8px;border-radius:6px;height:140px;overflow:auto;font-family:monospace;font-size:13px}
    label.small{font-size:12px;color:#9fb0da}
  </style>
</head>
<body>
  <div class="card">
    <h2>Camera Sender — Publisher</h2>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay" style="position:relative;margin-top:8px"></canvas>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <label class="small">Interval(ms): <input id="intervalInput" type="number" value="100" step="10" style="width:90px"></label>
      <label class="small">Quality: <input id="qualityInput" type="number" value="0.8" step="0.05" min="0.2" max="1.0" style="width:80px"></label>
      <label class="small">Detect thresh: <input id="threshInput" type="number" value="0.45" step="0.05" min="0.1" max="1.0" style="width:80px"></label>
    </div>

    <div id="log"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

  <script>
  const logEl = document.getElementById('log');
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const intervalInput = document.getElementById('intervalInput');
  const qualityInput = document.getElementById('qualityInput');
  const threshInput = document.getElementById('threshInput');

  const socket = io();
  let model = null;
  let stream = null;
  let running = false;
  let sendTimer = null;

  const snap = document.createElement('canvas');
  const sctx = snap.getContext('2d');

  // Alarm sound
  const alarm = new Audio("https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg");

  function log(t) {
    console.log(t);
    logEl.textContent += `[${new Date().toLocaleTimeString()}] ${t}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  async function start() {
    log('[LOCAL] loading model...');
    try {
      model = await cocoSsd.load();
      log('[MODEL] coco-ssd loaded');
    } catch (e) {
      log('[MODEL ERR] ' + e.message);
      return;
    }

    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 360 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      log('[CAM ERR] ' + e.message);
      return;
    }

    overlay.width = video.videoWidth || 640;
    overlay.height = video.videoHeight || 360;

    // smaller snapshot for speed
    snap.width = 320;
    snap.height = 180;

    running = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;

    detectLoop();
    scheduleSend();
    log('[LOCAL] started');
  }

  function stop() {
    running = false;
    if (sendTimer) { clearTimeout(sendTimer); sendTimer = null; }
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    video.srcObject = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    log('[LOCAL] stopped');
  }

  async function detectLoop() {
    if (!running) return;
    if (model && video.readyState >= 2) {
      try {
        const preds = await model.detect(video, 6);
        drawPreds(preds);
        const threshold = parseFloat(threshInput.value) || 0.45;
        preds.forEach(p => {
          if (p.score >= threshold) {
            const ev = { label: p.class, confidence: p.score, bbox: p.bbox, w: video.videoWidth, h: video.videoHeight };
            socket.emit('detection', ev);
            log(`[DETECT] ${ev.label} ${Math.round(ev.confidence*100)}%`);

            // Instant alarm for "person"
            if (p.class === "person") {
              alarm.play().catch(()=>{});
              flashOverlay();
            }
          }
        });
      } catch (err) {
        console.warn('detect err', err);
      }
    }
    requestAnimationFrame(detectLoop);
  }

  function drawPreds(preds) {
    const ctx = overlay.getContext('2d');
    ctx.clearRect(0,0,overlay.width,overlay.height);
    ctx.strokeStyle = '#00FF77';
    ctx.lineWidth = 2;
    ctx.font = '16px Inter, Arial';
    ctx.fillStyle = 'rgba(0,255,119,0.85)';
    preds.forEach(p => {
      const [x,y,w,h] = p.bbox;
      ctx.strokeRect(x,y,w,h);
      const txt = `${p.class} ${Math.round(p.score*100)}%`;
      ctx.fillText(txt, x + 6, y > 18 ? y - 6 : y + 18);
    });
  }

  // Overlay flash effect
  function flashOverlay() {
    overlay.style.border = "5px solid red";
    setTimeout(()=> overlay.style.border = "none", 300);
  }

 // Sends snapshot as real JPEG file (dashboard expects this)
async function scheduleSend() {
  if (!running) return;
  const intervalMs = Math.max(80, parseInt(intervalInput.value || '150')); // ~6–12 fps
  try {
    sctx.drawImage(video, 0, 0, snap.width, snap.height);
    const quality = Math.min(1, Math.max(0.3, parseFloat(qualityInput.value || '0.6')));
    snap.toBlob(async (blob) => {
      if (!blob) {
        sendTimer = setTimeout(scheduleSend, intervalMs);
        return;
      }
      try {
        const fd = new FormData();
        fd.append('frame', blob, 'frame.jpg');
        await fetch('/frame', { method: 'POST', body: fd });
      } catch (err) {
        log('[POST ERR] ' + err.message);
      } finally {
        sendTimer = setTimeout(scheduleSend, intervalMs);
      }
    }, 'image/jpeg', quality);
  } catch (err) {
    console.error('[SNAP ERR]', err);
    sendTimer = setTimeout(scheduleSend, intervalMs);
  }
}


  startBtn.onclick = start;
  stopBtn.onclick = stop;

  socket.on('connect', () => log('[SOCKET] connected ' + socket.id));
  socket.on('disconnect', () => log('[SOCKET] disconnected ' + socket.id));
</script>

</body>
</html>



