<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Camera Sender — Optimized</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{--bg:#071026;--card:#0f1724;--text:#e8eefc;--accent:#4da3ff}
    body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);padding:14px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:10px;max-width:720px;margin:0 auto}
    h2{margin:0 0 10px 0;color:var(--accent)}
    video, canvas{width:100%;border-radius:8px;background:#000;display:block}
    .controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
    input[type=number], input[type=range] {padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:#07102a;cursor:pointer;font-weight:700}
    #log{margin-top:8px;background:#07182a;padding:8px;border-radius:6px;height:140px;overflow:auto;font-family:monospace;font-size:13px}
    label.small{font-size:12px;color:#9fb0da}
  </style>
</head>
<body>
  <div class="card">
    <h2>Camera Sender — Publisher</h2>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay" style="position:relative;margin-top:8px"></canvas>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <label class="small">Interval(ms): <input id="intervalInput" type="number" value="100" step="10" style="width:90px"></label>
      <label class="small">Quality: <input id="qualityInput" type="number" value="0.8" step="0.05" min="0.2" max="1.0" style="width:80px"></label>
      <label class="small">Detect thresh: <input id="threshInput" type="number" value="0.45" step="0.05" min="0.1" max="1.0" style="width:80px"></label>
    </div>

    <div id="log"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

  <script>
    const logEl = document.getElementById('log');
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const intervalInput = document.getElementById('intervalInput');
    const qualityInput = document.getElementById('qualityInput');
    const threshInput = document.getElementById('threshInput');

    const socket = io();
    let model = null;
    let stream = null;
    let running = false;
    let sendTimer = null;

    const snap = document.createElement('canvas');
    const sctx = snap.getContext('2d');

    function log(t) {
      console.log(t);
      logEl.textContent += `[${new Date().toLocaleTimeString()}] ${t}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function start() {
      log('[LOCAL] loading model...');
      try {
        model = await cocoSsd.load();
        log('[MODEL] coco-ssd loaded');
      } catch (e) {
        log('[MODEL ERR] ' + e.message);
        return;
      }

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
      } catch (e) {
        log('[CAM ERR] ' + e.message);
        return;
      }

      overlay.width = video.videoWidth || 480;
      overlay.height = video.videoHeight || 360;

      snap.width = 480;
      snap.height = Math.round((video.videoHeight / (video.videoWidth || 480)) * 480) || 360;

      running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;

      detectLoop();
      scheduleSend();
      log('[LOCAL] started');
    }

    function stop() {
      running = false;
      if (sendTimer) { clearTimeout(sendTimer); sendTimer = null; }
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      video.srcObject = null;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      log('[LOCAL] stopped');
    }

    async function detectLoop() {
      if (!running) return;
      if (model && video.readyState >= 2) {
        try {
          const preds = await model.detect(video, 6);
          drawPreds(preds);
          const threshold = parseFloat(threshInput.value) || 0.45;
          preds.forEach(p => {
            if (p.score >= threshold) {
              // build event
              const ev = { label: p.class, confidence: p.score, bbox: p.bbox, w: video.videoWidth, h: video.videoHeight };
              socket.emit('detection', ev);
              log(`[DETECT] ${ev.label} ${Math.round(ev.confidence*100)}%`);
            }
          });
        } catch (err) {
          console.warn('detect err', err);
        }
      }
      requestAnimationFrame(detectLoop);
    }

    function drawPreds(preds) {
      const ctx = overlay.getContext('2d');
      overlay.width = video.videoWidth || overlay.width;
      overlay.height = video.videoHeight || overlay.height;
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.strokeStyle = '#00FF77';
      ctx.lineWidth = 2;
      ctx.font = '18px Inter, Arial';
      ctx.fillStyle = 'rgba(0,255,119,0.85)';
      preds.forEach(p => {
        const [x,y,w,h] = p.bbox;
        ctx.strokeRect(x,y,w,h);
        const txt = `${p.class} ${Math.round(p.score*100)}%`;
        ctx.fillText(txt, x + 6, y > 18 ? y - 6 : y + 18);
      });
    }

    // Sends snapshot to /frame using multipart/form-data (fast)
    async function scheduleSend() {
      if (!running) return;
      const intervalMs = Math.max(40, parseInt(intervalInput.value || '60'));
      try {
        // draw to snapshot canvas in source resolution
        sctx.drawImage(video, 0, 0, snap.width, snap.height);
        const quality = Math.min(1, Math.max(0.2, parseFloat(qualityInput.value || '0.6')));
        snap.toBlob(async (blob) => {
          if (!blob) {
            sendTimer = setTimeout(scheduleSend, intervalMs);
            return;
          }
          try {
            const fd = new FormData();
            fd.append('frame', blob, 'frame.jpg');
            const resp = await fetch('/frame', { method: 'POST', body: fd });
            if (resp && resp.ok) {
              // occasional log
              if (Math.random() < 0.06) log('[POST] frame uploaded');
            } else {
              log('[POST ERR] non-OK response');
            }
          } catch (err) {
            log('[POST ERR] ' + err.message);
          } finally {
            sendTimer = setTimeout(scheduleSend, intervalMs);
          }
        }, 'image/jpeg', quality);
      } catch (err) {
        console.error('[SNAP ERR]', err);
        sendTimer = setTimeout(scheduleSend, intervalMs);
      }
    }

    startBtn.onclick = start;
    stopBtn.onclick = stop;

    socket.on('connect', () => log('[SOCKET] connected ' + socket.id));
    socket.on('disconnect', () => log('[SOCKET] disconnected ' + socket.id));
  </script>
</body>
</html>

